## 操作系统课程

### 文件系统

#### 文件系统的引入

+ 解决信息数据的**组织存取**问题
+ 便于用户摆脱各种存储介质的特性和I/O指令的细节，方便地存取信息
+ 多用户协调共享，安全

#### 文件系统的定义

文件系统是操作系统中负责管理和存取文件信息的**软件机构**，包括

+ 负责文件操作和管理的程序模块
+ 管理文件所需的数据结构 (如目录表、文件控制块、存储分配表) 
+ 访问文件的一组操作

#### 文件系统的基本功能

+ 实现按名存取文件
+ 解决文件数据的组织结构问题，实现**逻辑结构到物理结构的转换**
+ 提供一组文件操作，包括文件的创建、删除、读写、修改属性等
+ 实现文件共享和保护

#### 文件的逻辑结构

+ 流式文件：有序字符的集合，顺序存放，无结构
+ 记录式文件：可看做一组连续顺序的记录的集合，有结构

​	流式文件管理简单，记录式文件需要管理记录结构信息

#### 文件的物理结构

​	块是存储介质上连续信息所组成的一个区域，也叫物理记录。块是主存储器和辅助存储设备交换信息的基本单位。

​	磁盘上每个物理块的位置可用**柱面号、磁头号和扇区号**表示，这些地址和物理块号一一对应。

（1）连续文件

​	由一组分配在磁盘连续区域的物理块组成。使用该方式存放的前提能够事先知道一个文件的大小。优点：**连续存取**时速度较快，**随机存取**效率高，因为一次磁盘寻道就可以读出整个文件。缺点：**磁盘空间碎片**和**文件长度不易扩展**。

（2）串联文件

​	文件的信息存于若干块物理块中，每个物理块的最末一个字作为链接字，它指出后继块的物理地址。优点：**消除磁盘碎片**，支持文件的长度**动态扩展**，连续存取时速度较快。缺点：随机访问效率低，且**数据块指针消耗了一定的存储空间**。

​	解决方式：使用文件映照技术，即把链接文件中的链接字显式地存放在内存的一张链接表中**，该表在整个磁盘仅设置一张，**每个表项中存放链接指针，指向下一个数据块号。内存中的这样一个表格称为**文件分配表（File Allocation Table，FAT）**。

（3）索引文件

​	文件由**数据和索引表**构成，索引表记录逻辑块号与物理块号之间的映射关系。优点：以上全部。缺点：存储索引带来的开销，以及查找索引表的时间消耗。

<img src="..\images\UNIX system V 文件索引结构.png" alt="UNIX system V 文件索引结构.png" style="zoom:67%;" />

#### 文件存储空间的管理

​	常用空闲块管理策略：空闲文件目录、空闲块链、位示图

#### 文件目录

​	文件目录是记录文件的名字、存放地址及其他有关文件的说明信息和控制信息的数据结构。文件目录将文件名和它们在辅存中的物理地址以及其他文件信息联系起来，实现了**按名字查找文件**。

​	文件目录项的内容：文件名、文件逻辑结构、文件物理结构、存取控制信息、管理信息、文件类型。

<img src="..\images\多级目录结构.png" alt="多级目录结构" style="zoom: 80%;" />

##### UNIX/Linux中的链接文件

（1）软链接

​	符号链接文件中并不包括实际的文件数据，而只是**包括了它指向文件的路径**（文件的内容），可以链接到任意的文件和目录（**可以跨文件系统**）。当用户对链接文件操作时，系统会自动的转到对源文件的操作，但是删除链接文件时，并不会删除源文件。 

（2）硬链接

​	即多个目录项指向同一个索引节点。 删除一个硬链接文件时，引用计数减1，只要不为0，文件索引节点和文件内容仍然存在。**硬链接不可用于跨文件系统**，并且不能是目录。

#### 文件共享与安全

​	文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用。共享会引发文件的安全问题。为了保障文件的安全，需要对文件进行保护，即文件本身不得被未经文件主授权的任何用户存取，而对于授权用户也只能在允许的存取权限内使用文件。常见的用户存取权限的类型包括EXCUTE、READ、UPDATE、WRITE、DELETE和CHANGE。验证用户存取权限的方法有访问控制矩阵、存取控制表、用户权限表等。



### UNIX文件系统

​	文件是无结构的字符流式文件，采用索引结构，目录采用树型层次结构。外部设备和目录统一被作为文件一样对待。

#### UNIX系统的索引文件结构

​	UNIX系统把文件目录项中除了名字以外的信息全部存放到一个磁盘的数据块上——文件索引节点(index node)。在目录项中只有文件的名字和对应i节点的编号。

![磁盘索引节点的结构](..\images\磁盘索引节点的结构.png)

#### UNIX系统文件目录结构

​	每个目录表为一个目录文件。目录文件由目录项组成。

![UNIX 树型目录结构](..\images\UNIX 树型目录结构.png)

#### UNIX系统的打开文件机构

​	文件目录结构，文件索引节点和索引表都存储在辅存上，为了提高系统效率，减少主存空间的占用，系统设置了打开文件和关闭文件操作。当打开一个文件时，建立用户与该文件的联系，就是将辅存中的相关目录项，辅存索引节点和索引表拷贝到主存中。文件系统中管理这一工作的机构称为打开文件机构。

打开文件机构的组成：

（1）活动 i 节点表

​	当执行打开文件操作时，将文件辅存i节点的有关信息拷贝到主存，形成活动 i 节点表。

（2）系统打开文件表

​	一个文件可以被同一进程或不同进程，用同一或不同路径名（硬链接），相同的或互异的操作要求 (读/写)同时打开。为了记录打开文件所需的**附加信息**，文件系统设置了一个**全局**核心结构 — 系统打开文件表。

（3）用户文件描述符表

​	进程控制块中的一个数组 u_ofile[NOFILE]，其中的每一项 (指针)指向系统打开文件表的一个表项。一个打开文件在用户文件描述表中对应项的下标就是它的文件描述符 。

<img src="..\images\用户文件描述符表、系统打开文件表、主存索引节点表之间的关系.png" alt="用户文件描述符表、系统打开文件表、主存索引节点表之间的关系" style="zoom:67%;" />



## TechTarget 对文件系统的定义

参考链接：

[What is a file system? | Definition from TechTarget](https://www.techtarget.com/searchstorage/definition/file-system)

​	在存储介质上定义文件和目录之前，必须先创建一个或多个**分区（partitions）** 。分区之间彼此**独立**，每个分区都可以使用不同的文件系统进行格式化，以提供更大的灵活性。

​	单独的分区有助于将文件和操作彼此隔离，这有利于性能、安全性和维护。例如，计算机的 SSD 可能包含三个分区：一个用于作系统文件，一个用于用户文件，一个用于系统的恢复文件。如果一个分区上的文件系统损坏，另一个分区上的数据应该是安全的。

​	文件系统将分区划分为多个块，其大小取决于文件系统。大多数块用于文件的内容数据，其余块用于存放文件的元数据和文件系统的管理数据等。

类 Unix 环境中的文件系统：

![img](https://www.techtarget.com/rms/onlineimages/file_systems_architecture-f.png)

### 几个经典的文件系统

#### File allocation table (FAT)

​	FAT 是一种简单可靠的文件系统，曾一度被早期版本的 Windows操作系统广泛使用。最初，FAT 是一个 8 位系统，但后来更新为 FAT12（12 位），然后是 FAT16（16 位），最后是 FAT32（32 位），这是仍在使用的主要版本。虽然 FAT 高效且与大多数当前操作系统兼容，但无法与更现代的文件系统的性能和可扩展性相媲美。

#### New Technology File System (NTFS)

​	NTFS 也称为 NT 文件系统，自 Windows NT 3.1 以来一直是默认的 Windows 文件系统。NTFS 对 FAT 文件系统进行了多项改进，包括更好的性能、元数据支持和资源利用率。

#### Extended filesystem (ext)

​	该文件系统于 1992 年实施，专为 Linux 设计，至今仍广泛用于 Linux 系统。当前版本 ext4 基于 ext3 构建，后者增加了日志功能以减少数据损坏。ext4 版本提供更好的性能和可靠性，同时支持更高的可扩展性。它是多个 Linux 发行版（包括 Ubuntu和 Debian）的默认文件系统，也是 Android 设备上使用的主要文件系统。



## linux 文件系统

参考链接：

[linux - 一口气搞懂「文件系统」，就靠这 25 张图了 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000023615225#comment-area)

### 文件系统的基本组成

#### 索引节点和目录项

​	Linux 文件系统会为每个文件分配两个数据结构：**索引节点（index node）**和**目录项（directory entry）**，它们主要用来记录文件的元信息和目录层次结构。

​	索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中。**索引节点占用磁盘空间**。

​	目录项用来记录文件的名字、**索引节点指针**以及**与其他目录项的层级关联关系**。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，**不存放于磁盘，而是缓存在内存**。如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存中的目录项中读就可以，大大提高了文件系统的效率。

#### 扇区和逻辑块

​	磁盘读写的最小单位是**扇区**，扇区的大小只有 512B 大小。如果每次读写都以一个扇区为单位，效率会非常低。所以，文件系统把多个扇区组成了一个**逻辑块**，每次读写的最小单位就是逻辑块（数据块）。Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。

### 虚拟文件系统

​	文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为**虚拟文件系统（Virtual File System，VFS）。**VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解具体文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。

<img src="https://segmentfault.com/img/remote/1460000023615230/view" alt="preview" style="zoom:50%;" />

​	根据存储位置的不同，可以把 Linux 支持的文件系统分为以下三类：

- **基于磁盘的文件系统**，它是直接把数据存储在磁盘中，如 Ext 2/3/4、XFS 等都是这类文件系统。
- **基于内存的文件系统**，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 /proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。
- **基于网络的文件系统**，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

​	文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。

### 文件系统的结构

​	Linux使用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配。当一个块的大小为4k时，一个块内的位图最大可表示的空间为128M，显然不够。

​	在 Linux 文件系统，把这个结构称为一个**块组**。

​	下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：

<img src="https://segmentfault.com/img/remote/1460000023615244/view" alt="preview" style="zoom:67%;" />

​	最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组，块组的内容如下：

- **超级块**，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。
- **块组描述符**，每个块组都包含了文件系统中**所有块组的组描述符信息**，比如块组中空闲块和 inode 的数目等。
- **数据位图和 inode 位图**。
- **inode 列表**。
- **数据块**。

​	每个块组里有很多重复的信息，比如**超级块和块组描述符表，这两个都是全局信息，而且非常的重要**，这么做是有两个原因：

- 如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。
- 通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。

### 文件 I/O

#### 缓冲与非缓冲 I/O

​	文件操作的标准库是可以实现数据的缓存。那么，根据**是否利用标准库缓冲**，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：

- 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。
- 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。

​	比如，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是减少系统调用的次数，因为系统调用有 CPU 上下文切换的开销。

#### 直接与非直接 I/O

​	磁盘 I/O 的速度十分缓慢，因此，Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是页缓存，只有**当缓存满足某些条件的时候**，才发起磁盘 I/O 的请求。那么，根据**是否利用操作系统的缓存**，可以把文件 I/O 分为直接 I/O 与非直接 I/O：

- 直接 I/O，不会发生内核缓存和用户程序之间的数据复制，而是直接经过文件系统访问磁盘。
- 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

​	如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。

#### 阻塞与非阻塞 I/O VS 同步与异步 I/O

<img src="https://segmentfault.com/img/remote/1460000023615253" alt="img" style="zoom:67%;" />

##### 阻塞I/O

​	当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。

​	注意，阻塞等待的是**内核数据准备好**和**数据从内核态拷贝到用户态**这两个过程。

<img src="https://segmentfault.com/img/remote/1460000023615251/view" alt="preview" style="zoom:67%;" />

##### 非阻塞I/O

​	非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。

​	注意，这里最后一次 read 调用获取数据的过程，是一个同步的过程，需要等待。非阻塞等待的是**数据从内核态拷贝到用户态**这个过程。

<img src="https://segmentfault.com/img/remote/1460000023615250/view" alt="preview" style="zoom:67%;" />

​	为了改善轮询方式的缺点，人们发明了**I/O 多路复用**技术，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以**事件通知应用程序**进行操作。该做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。

​	注意，read 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个**同步的过程**，需要等待。

<img src="https://segmentfault.com/img/remote/1460000023615252/view" alt="preview" style="zoom:67%;" />

​	实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用**都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间这个过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。**

##### 异步I/O

​	内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。当我们发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。

<img src="https://segmentfault.com/img/remote/1460000023615249/view" alt="preview" style="zoom:67%;" />

