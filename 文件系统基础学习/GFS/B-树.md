# B-树

参考链接：

[讲点"B树"，一文详解B-树，B+树，B*树；及其优缺点比较， - 知乎](https://zhuanlan.zhihu.com/p/105066820)

[图解：什么是B树？（心中有 B 树，做人要虚心）一文读懂B-树 - 知乎](https://zhuanlan.zhihu.com/p/146252512)

[B树与B+树与磁盘读取的联系_b+树读写磁盘-CSDN博客](https://blog.csdn.net/bengshakalakaka/article/details/89255902)

[深入探讨磁盘B树的内部机制：代码实现与理论解析 - 知乎](https://zhuanlan.zhihu.com/p/655982472)

[一文彻底搞懂MySQL基础：B树和B+树的区别_mysql b树和b+树的区别-CSDN博客](https://blog.csdn.net/a519640026/article/details/106940115)

​	B-树是一种**多路平衡查找树**，其每个节点的孩子个数由其阶数控制（[*$\lceil m / 2 \rceil, m$*]），所有叶子结点都位于同一层，节点内部关键字保持有序。**键值对分布在整颗树中**（包括内部节点和叶子结点），每个键只在树中出现一次，存储空间更高效。其搜索性能等价于在关键字全集内做一次二分查找。

![clip_image002](https://i-blog.csdnimg.cn/blog_migrate/7003cea2d6a2dbaebc44c64fc931d9a6.png)

​	B-树为磁盘访问专门做了优化。传统的二分搜索树的节点保存在内存中，查找过程包括比较和寻址，寻址次数和层高成正比。然而，在某些情况下，数据需要保存到磁盘中（数据量大内存不够或者需要永久存储等），二叉树相邻两次寻址跨越的地址范围可能很大，**无法利用磁盘预读**，速度很慢。因此衍生出一些降低层高的数据结构，如AVL树、红黑树、B-树和B+树。在B-树中，一个节点可以保存多个键，这种多叉结构有效降低了层高，同时，一个节点保存在一页中，只需要一次寻址。因此，B-树磁盘寻址次数少，速度更快。可以这样理解，同样是一次磁盘I/O，**B-树的每个节点将数据范围划分为多个区间，实现了更精确的定位**，这样只需要更少的次数就能找到键。

​	B+树是B-树的扩展或变种，**B+树的内节点不存储值，只做索引，所有的数据都存储在叶子节点**，且叶子结点通过指针相连构成链表。

![clip_image061](https://i-blog.csdnimg.cn/blog_migrate/139a610c9c86f83234b0894d777628bb.png)

​	B+树的优点：

+ B+树相邻叶节点的指针使其**对范围查询有更好的支持**。
+ **B+树更适合外部存储**。在节点大小相同的情况下，由于内节点无 data 域，每个节点能索引的范围更大更精确，树的层高更低；在关键字数目相同的情况下，B+树内部节点占用的空间更小。
+ 查询性能较为稳定。

​	B-树的优点：

+ 查询时间复杂度不固定，和 key 在树中的位置有关，最好为O(1)，而 B+树固定为O(log n)。

​	GFS 使用一种紧凑的类似于 B-树的形式保存检查点。为什么不用二叉搜索树？为什么不用B+树？磁盘读写，查找效率，适合压缩